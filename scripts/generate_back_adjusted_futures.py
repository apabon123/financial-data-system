#!/usr/bin/env python
"""
Generates back-adjusted continuous futures contracts.

Reads individual contract data (daily OHLCV) from the 'market_data' table,
loads roll dates from the 'futures_roll_dates' table (generated by
calculate_volume_roll_dates.py), performs back-adjustment calculations,
and saves the adjusted continuous contract data to the 'continuous_contracts' table.
"""

import logging
import argparse
import sys
from pathlib import Path
from datetime import timedelta
import pandas as pd
import duckdb
import yaml
from typing import Dict, Any, List, Optional

# --- Configuration ---
logging.basicConfig(
    level=logging.INFO,
    format='[%(asctime)s] %(levelname)-8s %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger('back_adjust')

PROJECT_ROOT = Path(__file__).resolve().parents[1] # Adjust if script location changes
DEFAULT_DB_PATH = PROJECT_ROOT / "data" / "financial_data.duckdb"
DEFAULT_CONFIG_PATH = PROJECT_ROOT / "config" / "market_symbols.yaml"
DEFAULT_ROLL_TYPE = "volume"

# --- Database & Config Functions ---

def connect_db(db_path: Path, read_only: bool = True):
    """Connects to the DuckDB database."""
    try:
        logger.info(f"Connecting to database ('{'read_only' if read_only else 'read-write'}'): {db_path}")
        con = duckdb.connect(database=str(db_path), read_only=read_only)
        return con
    except Exception as e:
        logger.error(f"Failed to connect to database: {e}")
        sys.exit(1)

def load_config(config_path: Path) -> Dict[str, Any]:
    """Loads the market symbols configuration from a YAML file."""
    try:
        with open(config_path, 'r') as f:
            config = yaml.safe_load(f)
        logger.info(f"Configuration loaded from: {config_path}")
        return config
    except FileNotFoundError:
        logger.error(f"Configuration file not found: {config_path}")
        sys.exit(1)
    except Exception as e:
        logger.error(f"Error loading configuration: {e}")
        sys.exit(1)

def load_roll_dates_from_db(root_symbol: str, roll_type: str, con) -> pd.DataFrame:
    """Loads roll dates for a specific root symbol and roll type from the database."""
    logger.info(f"Loading '{roll_type}' roll dates for {root_symbol} from database...")
    query = """
    SELECT Contract, RollDate
    FROM futures_roll_dates
    WHERE SymbolRoot = ? AND RollType = ?
    ORDER BY RollDate; 
    """
    try:
        roll_dates_df = con.execute(query, [root_symbol, roll_type]).fetchdf()
        if roll_dates_df.empty:
            logger.error(f"No roll dates found for {root_symbol} with type '{roll_type}'. Run calculate_volume_roll_dates.py first.")
            return pd.DataFrame() # Return empty df to signal failure downstream
        
        # Convert RollDate to date objects for comparison
        roll_dates_df['RollDate'] = pd.to_datetime(roll_dates_df['RollDate']).dt.date
        # Set Contract as index for easy lookup
        roll_dates_df = roll_dates_df.set_index('Contract')
        logger.info(f"Loaded {len(roll_dates_df)} roll dates.")
        return roll_dates_df
    except Exception as e:
        logger.error(f"Error loading roll dates from database: {e}")
        return pd.DataFrame()

def get_ordered_contracts(root_symbol: str, con) -> List[str]:
    """Gets an ordered list of individual contract symbols from the market_data table."""
    logger.info(f"Fetching ordered contract list for {root_symbol}...")
    query = f"""
    SELECT DISTINCT symbol 
    FROM market_data 
    WHERE symbol LIKE ? 
      AND symbol NOT LIKE ? -- Exclude continuous contracts
      -- Accept either daily interval signature
      AND (
           (interval_value = 1 AND interval_unit = 'day')
           OR
           (interval_unit = 'daily')
          )
    ORDER BY SUBSTRING(symbol, -2), -- Sort by year first
             CASE SUBSTRING(symbol, -3, 1) -- Then by month code order
                 WHEN 'F' THEN 1 WHEN 'G' THEN 2 WHEN 'H' THEN 3 WHEN 'J' THEN 4
                 WHEN 'K' THEN 5 WHEN 'M' THEN 6 WHEN 'N' THEN 7 WHEN 'Q' THEN 8
                 WHEN 'U' THEN 9 WHEN 'V' THEN 10 WHEN 'X' THEN 11 WHEN 'Z' THEN 12
                 ELSE 99
             END;
    """
    try:
        contracts_df = con.execute(query, [f"{root_symbol}%", f"{root_symbol}c%"]).fetchdf()
        contracts = contracts_df['symbol'].tolist()
        if not contracts:
            logger.warning(f"No individual daily contracts found for {root_symbol} in market_data.")
        else:
            logger.info(f"Found {len(contracts)} ordered contracts.")
        return contracts
    except Exception as e:
        logger.error(f"Error fetching contracts: {e}")
        return []

def get_contract_data_segment(symbol: str, start_date: Optional[pd.Timestamp], end_date: pd.Timestamp, con) -> pd.DataFrame:
    """Fetches the daily OHLCV data for a specific contract within a date range."""
    logger.debug(f"Fetching segment for {symbol} from {start_date} to {end_date}")
    query = """
    SELECT 
        timestamp::DATE as date, 
        open, high, low, close, volume
    FROM market_data
    WHERE symbol = ? 
      -- Use flexible daily interval check
      AND (
           (interval_value = 1 AND interval_unit = 'day')
           OR
           (interval_unit = 'daily') 
          )
      AND timestamp::DATE >= ? 
      AND timestamp::DATE <= ? 
    ORDER BY timestamp;
    """
    try:
        # Handle potential None start_date (for the very first contract)
        effective_start_date = start_date if start_date else pd.Timestamp('1900-01-01').date() # Ensure it's a date type
        # Pass date objects directly to the query parameters
        df = con.execute(query, [symbol, effective_start_date, end_date]).fetchdf()
        if not df.empty:
            df['date'] = pd.to_datetime(df['date'])
            df = df.set_index('date')
            # Ensure numeric types, handle potential missing values
            for col in ['open', 'high', 'low', 'close']:
                 df[col] = pd.to_numeric(df[col], errors='coerce')
            df['volume'] = pd.to_numeric(df['volume'], errors='coerce').fillna(0).astype('int64')
        return df
    except Exception as e:
        logger.error(f"Error fetching data segment for {symbol}: {e}")
        return pd.DataFrame()

def get_close_on_date(symbol: str, target_date: pd.Timestamp, con) -> Optional[float]:
    """Gets the closing price for a symbol on or immediately before a specific date."""
    query = """
    SELECT close 
    FROM market_data 
    WHERE symbol = ? 
      AND timestamp::DATE <= ? -- Look on or before the target date
      AND interval_value = 1 AND interval_unit = 'day'
    ORDER BY timestamp DESC -- Get the latest one first
    LIMIT 1;
    """
    try:
        result = con.execute(query, [symbol, target_date]).fetchone()
        return float(result[0]) if result and result[0] is not None else None
    except Exception as e:
        logger.warning(f"Could not get close for {symbol} on {target_date}: {e}")
        return None

# --- Back-Adjustment Logic ---

def back_adjust(ordered_contracts: List[str], roll_dates_map: Dict[str, Any], con) -> pd.DataFrame:
    """Performs back-adjustment on futures contracts.

    Args:
        ordered_contracts (List[str]): Chronologically sorted list of contract symbols.
        roll_dates_map (Dict[str, Any]): Dictionary mapping Contract -> RollDate.
        con: Database connection.

    Returns:
        pd.DataFrame: A single DataFrame with the back-adjusted continuous contract.
                       Columns: [open, high, low, close, volume, underlying_symbol]
                       Index: DatetimeIndex (date)
    """
    logger.info("Starting back-adjustment process...")
    all_adjusted_segments = []
    cumulative_adjustment = 0.0

    if not ordered_contracts:
        logger.error("No contracts provided for back-adjustment.")
        return pd.DataFrame()

    # Iterate backwards through contracts (except the very last one)
    for i in range(len(ordered_contracts) - 1, 0, -1):
        current_contract = ordered_contracts[i]
        previous_contract = ordered_contracts[i-1]
        logger.debug(f"Processing roll from {previous_contract} -> {current_contract}")

        # Find the roll date for the *previous* contract (this is when we adjust *its* data)
        contract_code_prev = previous_contract[-3:] # e.g., U23, Z23
        roll_date = roll_dates_map.get(contract_code_prev)
        
        if roll_date is None:
            logger.warning(f"No roll date found for {previous_contract} in roll calendar. Skipping adjustment for this contract.")
            # We might still need to fetch its data if it's the first segment
            roll_date_for_segment_end = None 
        else:
            roll_date_for_segment_end = roll_date
            logger.debug(f"Roll date for {previous_contract}: {roll_date}")

            # Get closing prices on the roll date
            prev_close = get_close_on_date(previous_contract, roll_date, con)
            curr_close = get_close_on_date(current_contract, roll_date, con)

            if prev_close is not None and curr_close is not None:
                adjustment = curr_close - prev_close
                cumulative_adjustment += adjustment
                logger.info(f"Roll {previous_contract}->{current_contract} on {roll_date}: PrevClose={prev_close:.2f}, CurrClose={curr_close:.2f}, Adjust={adjustment:.2f}, CumAdjust={cumulative_adjustment:.2f}")
            else:
                logger.warning(f"Could not get closing prices on roll date {roll_date} for {previous_contract} ({prev_close}) or {current_contract} ({curr_close}). Skipping adjustment step.")
        
        # Determine the date range for the *previous* contract segment
        # End date is its roll date (exclusive, so day before)
        segment_end_date = roll_date_for_segment_end - timedelta(days=1) if roll_date_for_segment_end else None
        # Start date is the roll date of the contract before it (exclusive, so roll date itself)
        # Or None if it's the very first contract in the list
        prev_prev_contract_code = ordered_contracts[i-2][-3:] if i > 1 else None
        segment_start_date = roll_dates_map.get(prev_prev_contract_code) if prev_prev_contract_code else None 
        
        if segment_end_date is None:
             logger.warning(f"Could not determine segment end date for {previous_contract}, skipping fetch.")
             continue
             
        logger.debug(f"Fetching segment data for {previous_contract} from {segment_start_date} to {segment_end_date}")

        # Fetch the data segment for the previous contract
        segment_df = get_contract_data_segment(previous_contract, segment_start_date, segment_end_date, con)

        if not segment_df.empty:
            # Apply the cumulative adjustment
            logger.debug(f"Applying cumulative adjustment of {cumulative_adjustment:.4f} to {len(segment_df)} rows for {previous_contract}")
            for col in ['open', 'high', 'low', 'close']:
                 segment_df[col] = segment_df[col] + cumulative_adjustment
            
            segment_df['underlying_symbol'] = previous_contract
            all_adjusted_segments.append(segment_df[['open', 'high', 'low', 'close', 'volume', 'underlying_symbol']])
        else:
             logger.warning(f"No data found for segment of {previous_contract} between {segment_start_date} and {segment_end_date}")

    # Handle the most recent contract (no adjustment needed for it)
    last_contract = ordered_contracts[-1]
    logger.debug(f"Processing final segment for {last_contract}")
    last_segment_start_date = roll_dates_map.get(ordered_contracts[-2][-3:]) if len(ordered_contracts) > 1 else None
    last_segment_end_date = pd.Timestamp.now().date() # Fetch up to today
    
    if last_segment_start_date:
        segment_df_last = get_contract_data_segment(last_contract, last_segment_start_date, last_segment_end_date, con)
        if not segment_df_last.empty:
            segment_df_last['underlying_symbol'] = last_contract
            all_adjusted_segments.append(segment_df_last[['open', 'high', 'low', 'close', 'volume', 'underlying_symbol']])
        else:
            logger.warning(f"No data found for final segment of {last_contract} starting {last_segment_start_date}")
    elif len(ordered_contracts) == 1:
         # Handle case where only one contract exists in total
         segment_df_last = get_contract_data_segment(last_contract, None, last_segment_end_date, con)
         if not segment_df_last.empty:
            segment_df_last['underlying_symbol'] = last_contract
            all_adjusted_segments.append(segment_df_last[['open', 'high', 'low', 'close', 'volume', 'underlying_symbol']])
         else:
            logger.warning(f"No data found for the only contract {last_contract}")
    else:
         # Case where there are multiple contracts but the roll date for the second-to-last is missing
         logger.warning(f"Cannot determine start date for the final segment of {last_contract} because roll date for {ordered_contracts[-2]} is missing. Skipping final segment.")

    if not all_adjusted_segments:
        logger.error("No adjusted segments were generated.")
        return pd.DataFrame()

    # Concatenate all segments (they should be in reverse chronological order)
    final_df = pd.concat(all_adjusted_segments)
    # Sort by date index to get chronological order
    final_df = final_df.sort_index()

    logger.info(f"Back-adjustment complete. Generated {len(final_df)} total rows.")
    return final_df

# --- Saving Logic ---

def _ensure_continuous_contracts_table(con):
    """Ensures the continuous_contracts table exists in the database."""
    try:
        con.execute("""
            CREATE TABLE IF NOT EXISTS continuous_contracts (
                timestamp TIMESTAMP NOT NULL,
                symbol VARCHAR NOT NULL,       -- Continuous contract symbol (e.g., ES_adj_volume)
                underlying_symbol VARCHAR, -- Specific contract used for this row (e.g., ESH24)
                open DOUBLE,
                high DOUBLE,
                low DOUBLE,
                close DOUBLE,
                volume BIGINT,
                -- Add other columns like open_interest, up/down volume if needed later
                PRIMARY KEY (timestamp, symbol)
            );
        """)
        logger.info("Table 'continuous_contracts' verified/created successfully.")
    except Exception as e:
        logger.error(f"Error creating/verifying continuous_contracts table: {e}")
        raise

def save_adjusted_contract(df: pd.DataFrame, output_symbol: str, force: bool, con):
    """Saves the adjusted continuous contract data to the database."""
    if df.empty:
        logger.warning(f"No adjusted data provided for {output_symbol}. Nothing to save.")
        return

    table_name = "continuous_contracts"
    
    try:
        _ensure_continuous_contracts_table(con) # Ensure table exists

        if force:
            logger.info(f"Force mode: Deleting existing data for {output_symbol} in {table_name}...")
            con.execute(f"DELETE FROM {table_name} WHERE symbol = ?", [output_symbol])
            deleted_count = con.fetchone()[0] if con.last_changes() > 0 else 0
            logger.info(f"Deleted {deleted_count} existing rows for {output_symbol}.")

        # Prepare dataframe for insertion
        df_to_insert = df.copy()
        df_to_insert['symbol'] = output_symbol
        df_to_insert = df_to_insert.reset_index().rename(columns={'date': 'timestamp'})
        # Ensure timestamp is in the correct format (datetime64[us])
        df_to_insert['timestamp'] = pd.to_datetime(df_to_insert['timestamp']).astype('datetime64[us]')

        # Select and order columns for insertion
        insert_cols = ['timestamp', 'symbol', 'underlying_symbol', 'open', 'high', 'low', 'close', 'volume']
        df_to_insert = df_to_insert[insert_cols]

        # Use direct DataFrame upsert
        temp_view_name = f"temp_cont_{output_symbol}_upsert"
        con.register(temp_view_name, df_to_insert)

        sql = f"""
        INSERT INTO {table_name} (timestamp, symbol, underlying_symbol, open, high, low, close, volume)
        SELECT timestamp, symbol, underlying_symbol, open, high, low, close, volume FROM {temp_view_name}
        ON CONFLICT (timestamp, symbol) DO UPDATE SET
            underlying_symbol = EXCLUDED.underlying_symbol,
            open = EXCLUDED.open,
            high = EXCLUDED.high,
            low = EXCLUDED.low,
            close = EXCLUDED.close,
            volume = EXCLUDED.volume
        """
        
        con.execute(sql)
        con.unregister(temp_view_name)
        con.commit()
        logger.info(f"Successfully upserted {len(df_to_insert)} rows into {table_name} for {output_symbol}.")

    except Exception as e:
        logger.error(f"Error saving adjusted contract {output_symbol} to database: {e}")
        con.rollback()
        import traceback
        traceback.print_exc()

# --- Main Execution ---

def main():
    parser = argparse.ArgumentParser(description='Generate back-adjusted continuous futures contracts.')
    parser.add_argument('--root-symbol', required=True, help='Root symbol (e.g., ES, NQ).')
    parser.add_argument('--db-path', default=str(DEFAULT_DB_PATH), help='Path to the DuckDB database file.')
    parser.add_argument('--config-path', default=str(DEFAULT_CONFIG_PATH), help='Path to market symbols config file.')
    parser.add_argument('--roll-calendar-path', help='(DEPRECATED) Path to roll calendar CSV file.') # Kept for backward compat warning
    parser.add_argument('--roll-type', default=DEFAULT_ROLL_TYPE, help=f'Roll type identifier in futures_roll_dates table (default: {DEFAULT_ROLL_TYPE}).')
    parser.add_argument('--output-symbol', help='Symbol name for the output continuous contract (e.g., ES_adj_volume). Defaults to {root_symbol}_adj_{roll_type}.')
    parser.add_argument('--force', action='store_true', help='Force overwrite of existing data for the output symbol.')

    args = parser.parse_args()

    if args.roll_calendar_path:
        logger.warning("--roll-calendar-path is deprecated. Roll dates are now loaded from the database based on --roll-type.")

    output_symbol = args.output_symbol or f"{args.root_symbol}_adj_{args.roll_type}"
    logger.info(f"--- Starting Back-Adjusted Contract Generation for {args.root_symbol} --- ")
    logger.info(f"Roll Type: {args.roll_type}")
    logger.info(f"Output Symbol: {output_symbol}")
    logger.info(f"Database: {args.db_path}")
    logger.info(f"Force Overwrite: {args.force}")

    con = None # Initialize connection variable
    try:
        # Connect read-only initially for loading
        con = connect_db(Path(args.db_path), read_only=True)
        
        # Load necessary inputs
        config = load_config(Path(args.config_path))
        roll_dates_df = load_roll_dates_from_db(args.root_symbol, args.roll_type, con)
        if roll_dates_df.empty:
            sys.exit(1) # Stop if roll dates couldn't be loaded
        roll_dates_map = roll_dates_df['RollDate'].to_dict() # Convert to dict for faster lookup
        
        ordered_contracts = get_ordered_contracts(args.root_symbol, con)
        if not ordered_contracts:
             sys.exit(1) # Stop if no contracts found
             
        # Perform back-adjustment
        adjusted_df = back_adjust(ordered_contracts, roll_dates_map, con)
        
        # Close read-only connection before saving
        con.close()
        logger.info("Read-only connection closed.")
        con = None # Reset connection variable

        # Save results (requires read-write connection)
        if not adjusted_df.empty:
            con_rw = connect_db(Path(args.db_path), read_only=False)
            save_adjusted_contract(adjusted_df, output_symbol, args.force, con_rw)
            con = con_rw # Assign RW connection to con for finally block
        else:
            logger.warning("No adjusted data was generated, nothing to save.")

        logger.info(f"--- Finished Back-Adjusted Contract Generation for {args.root_symbol} --- ")

    except Exception as e:
        logger.error(f"An unexpected error occurred during main execution: {e}", exc_info=True)
    finally:
        if con:
            try:
                con.close()
                logger.info("Database connection closed.")
            except Exception as e_close:
                 logger.error(f"Error closing database connection: {e_close}")

if __name__ == "__main__":
    main() 